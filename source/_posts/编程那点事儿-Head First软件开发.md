---
title: Head First 软件开发
date: 2017-07-28 20:36:21
categories: 编程那点事儿
tags:
  - 软件开发
  - 读书
---
<blockquote class="blockquote-center">**软件开发** —— ⭐️What is needed, ⭐️On time, ⭐️On budget.
</blockquote>

<!--more-->

## 写在前面

计算机，这个炙手可热的高科技词汇，其实拆穿本质，和英语一样 —— 都是工具。

早些年改革开放，为了和国际接轨，英语成为我们中国学生的主科，以求将来能看懂英文文档，能用英语能跟强大的老外打交道...那时候，英语跟语文、数学地位一样重要。当时计算机技术没有现在发达，经济条件也不允许有个人电脑，所以和英语比起来计算机的受众没有英语广。只有富贵人家弄潮儿才玩得起这种高级“玩具”（没错，很多人刚拥有个人电脑的时候就是为了能打电子游戏... **也许是生物原始的欲望促进了科技的发展** ？直播，VR... 都是从色情行业发迹的... 当然这是另一个话题，暂按下不表）。

如今不一样了，几乎每人一台电脑（手机就是一台掌上电脑）。如此发展之下，必然造成一个后果 —— 计算机技术的地位和英语一样重要，甚至比英语还重要。如果不会用智能手机（一些老人），不会操作一些 APP（支付宝，ofo，滴滴...），那生活中将寸步难行（想象一下你在英语国家生活却不会讲英语罢）。

说回重点：重要的计算机技术，重要在 **软件开发**。

昨天回母校跟老师探讨他自主开发的土建工程计算软件 [RBCCE](http://rbcce.com/ "RBCCE")，需求、前景、技术细节、盈利模式... 谈得挺多也挺杂乱，本以为能探讨一整天，却用了一上午草草收场... 未免也太不专业了！无论是沟通技巧还是专业能力，肯定哪里存在没有被我们当场发现的问题。

盲人摸象，肯定不能得出一个统一的结论。于是，从书中找答案吧。

## 《Head First 软件开发》

Head First 系列，用最少的专业词汇最快的速度带你鸟瞰最专业的领域。这本书介绍了一个软件从 0 到这款软件在世界上健康运营的全生命周期。

软件开发流程：向客户收集需求 ➡️ 项目规划 ➡️ user story 情节和任务 ➡️ 版本控制 ➡️ 测试和连续集成 ➡️ 测试驱动开发 ➡️ 进入下一个循环 ...

（书还没看完，看完来补充笔记）。。。

## 《Software Architecture Patterns》

软件架构（software architecture）就是软件的基本结构。

合适的架构是软件成功的最重要因素之一。大型软件公司通常有专门的架构师职位（architect），只有资深程序员才可以担任。

O'Reilly 出版过（上面的 Head First 系列也是他们出版的）一本免费的小册子《Software Architecture Patterns》， 介绍了五种最常见的软件架构：

- 分层架构
- 事件驱动架构
- 微核架构
- 微服务架构
- 云架构

{% pdf http://ogudt6aal.bkt.clouddn.com/file/software-architecture-patterns.pdf %}

下面一一介绍。

### 分层架构

分层架构（layered architecture）是最常见的标准架构。如果你不知道要用什么架构，那就用它。

这种架构将软件分成若干个水平层，每一层都有清晰的角色和分工，不需要知道其他层的细节。层与层之间通过接口通信。

虽然没有明确约定，软件一定要分成多少层，但是四层的结构最常见。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810171017_9ASvDO_bg2016090302.jpeg)

用户的请求将依次通过这四层的处理，不能跳过其中任何一层。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810171109_pql7iv_bg2016090303.jpeg)

有时在业务层和持久层之间，加一个服务层（service），提供不同业务逻辑需要的一些通用接口。

优点：
<blockquote>
- 结构简单，容易理解和开发  
- 不同技能的程序员可以分工，负责不同的层，天然适合大多数软件公司的组织架构  
- 每一层都可以 **独立测试**，其他层的接口通过模拟解决
</blockquote>
缺点：
<blockquote>
- 一旦环境变化，需要代码调整或增加功能时，通常比较麻烦和费时  
- 部署比较麻烦，即使只修改一个小地方，往往需要整个软件重新部署，不容易做持续发布  
- 软件升级时，可能需要整个服务暂停  
- **扩展性差**。用户请求大量增加时，必须依次扩展每一层，由于每一层内部是耦合的，扩展会很困难
</blockquote>

### 事件驱动架构

事件（event）是状态发生变化时，软件发出的通知。

事件驱动架构（event-driven architecture）就是通过事件进行通信的软件架构。它分成四个部分。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810172344_bsW8T0_bg2016090304.jpeg)

- 事件队列：接收事件的入口
- 分发器：将不同的事件分发到不同的业务逻辑单元
- 事件通道：分发器与处理器之间的联系渠道
- 事件处理器：实现业务逻辑，处理完成后会发出事件，触发下一步操作

对于简单的项目，事件队列、分发器和事件通道，可以合为一体，整个软件就分成事件代理和事件处理器两部分。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810172630_QzPyvp_bg2016090305.jpeg)

优点：
<blockquote>
- 分布式的异步架构，事件处理器之间高度解耦，软件的 **扩展性好**  
- 适用性广，各种类型的项目都可以用  
- 性能较好，因为事件的异步本质，软件不易产生堵塞  
- 事件处理器可以独立地加载和卸载，容易部署
</blockquote>
缺点：
<blockquote>
- 涉及异步编程（要考虑远程通信、失去响应等情况），开发相对复杂
- 难以支持原子性操作，因为事件通过会涉及多个处理器，很难回滚
- 分布式和异步特性导致这个架构 **较难测试**
</blockquote>

### 微核架构

微核架构（microkernel architecture）又称为"插件架构"（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。

内核（core）通常只包含系统运行的最小功能。插件则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810173423_d1622S_bg2016090306.jpeg)

优点：
<blockquote>
- 良好的功能 **延伸性**（extensibility），需要什么功能，开发一个插件即可
- 功能之间是隔离的，插件可以独立的加载和卸载，使得它比较容易部署，
- **可定制性高**，适应不同的开发需要
- 可以渐进式地开发，逐步增加功能
</blockquote>
缺点：
<blockquote>
- **扩展性（scalability）差**，内核通常是一个独立单元，不容易做成分布式
- 开发 **难度相对较高**，因为涉及到插件与内核的通信，以及内部的插件登记机制
</blockquote>

<br>

比如浏览器，有各种插件；各种拥有二次开发的专业客户端软件。

### 微服务架构

微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。

每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。

微服务架构分成三种实现模式：

- RESTful API 模式：服务通过 API 提供，云服务就属于这一类
- RESTful 应用模式：服务通过传统的网络协议或者应用协议提供，背后通常是一个多功能的应用程序，常见于企业内部
- 集中消息模式：采用消息代理（message broker），可以实现消息队列、负载均衡、统一日志和异常处理，缺点是会出现单点失败，消息代理可能要做成集群

![](http://ogudt6aal.bkt.clouddn.com/image/20170810174449_8EpUgy_bg2016090307.jpeg)

优点：
<blockquote>
- 扩展性好，各个服务之间低耦合  
- 容易部署，软件从单一可部署单元，被拆成了多个服务，每个服务都是可部署单元  
- 容易开发，每个组件都可以进行持续集成式的开发，可以做到实时部署，不间断地升级  
- 易于测试，可以单独测试每一个服务
</blockquote>
缺点：
<blockquote>
- 由于强调互相独立和低耦合，服务可能会拆分得很细。这导致系统依赖大量的微服务，变得很 **凌乱和笨重**，性能也会不佳。  
- 一旦服务之间需要通信（即一个服务要用到另一个服务），整个架构就会变得复杂。典型的例子就是一些通用的 Utility 类，一种解决方案是把它们拷贝到每一个服务中去，**用冗余换取架构的简单性**。  
- 分布式的本质使得这种架构很难实现原子性操作，交易回滚会比较困难。
</blockquote>

### 云架构

云架构（cloud architecture）主要解决扩展性和并发的问题，是最容易扩展的架构。

它的高扩展性，主要原因是没使用中央数据库，而是把数据都复制到内存中，变成可复制的内存数据单元。然后，业务处理能力封装成一个个处理单元（prcessing unit）。访问量增加，就新建处理单元；访问量减少，就关闭处理单元。由于没有中央数据库，所以扩展性的最大瓶颈消失了。由于每个处理单元的数据都在内存里，最好要进行数据持久化。

这个模式主要分成两部分：处理单元（processing unit）和虚拟中间件（virtualized middleware）。

![](http://ogudt6aal.bkt.clouddn.com/image/20170810175647_10x9CY_bg2016090311.jpeg)

- 处理单元：实现业务逻辑
- 虚拟中间件：负责通信、保持sessions、数据复制、分布式处理、处理单元的部署。

虚拟中间件又包含四个组件：
- 消息中间件（Messaging Grid）：管理用户请求和session，当一个请求进来以后，决定分配给哪一个处理单元。
- 数据中间件（Data Grid）：将数据复制到每一个处理单元，即数据同步。保证某个处理单元都得到同样的数据。
- 处理中间件（Processing Grid）：可选，如果一个请求涉及不同类型的处理单元，该中间件负责协调处理单元
- 部署中间件（Deployment Manager）：负责处理单元的启动和关闭，监控负载和响应时间，当负载增加，就新启动处理单元，负载减少，就关闭处理单元。

优点：
<blockquote>
- **高负载**，高扩展性  
- **动态部署**
</blockquote>
缺点：
<blockquote>
- **实现复杂，成本较高**  
- 主要适合网站类应用，不合适大量数据吞吐的大型数据库应用  
- **较难测试**
</blockquote>

<br>

后面这两种可以想一想阿里云服务器：

![](http://ogudt6aal.bkt.clouddn.com/image/20170810174722_cwMmvb_aliyunservice.jpeg)

<blockquote>
注：《Software Architecture Patterns》知识整理于 [阮一峰博客](http://www.ruanyifeng.com/blog/2016/09/software-architecture.html "阮一峰博客")。
</blockquote>

---

## 结语

开头说到，**计算机和英语都是工具。** 写到这里的时候我想到了另外一个进阶的类比：

当你掌握了英语之后，给你提供了三种工作机会：

1. 在出版社替人家翻译需要翻译的文稿或图书（“专业”翻译从业人员，他们有时候会借助各种工具来翻译[并且一塌糊涂](http://www.ruanyifeng.com/blog/2005/08/post_136.html "并且一塌糊涂")）![](http://ogudt6aal.bkt.clouddn.com/image/20170813012405_PHgWKJ_fanyi.jpeg)
2. 翻译自己喜欢的英文原版书去出版，即使这本书可能不会畅销（比如阮一峰翻译的《黑客与画家》，不过很畅销；比如李笑来知笔墨翻译的[《精通比特币》](http://www.zhibimo.com/books/wang-miao/mastering-bitcoin "《精通比特币》")和整理的[《How To Start A Startup - A YC Course》](http://www.zhibimo.com/books/xiaolai/how-to-start-a-startup-a-yc-course "《How To Start A Startup - A YC Course》")并写了[自己的笔记](http://www.zhibimo.com/books/xiaolai/growth "自己的笔记")）
3. 自己写英文原版文稿或图书，即使可能费力且收入甚微（比如王建硕刚开始写的博客，如图：![](http://ogudt6aal.bkt.clouddn.com/image/20170813011151_rIvUKW_wangjianshuo.jpeg) 全文链接[戳我](http://www.ruanyifeng.com/blog/2010/04/talk_with_wangjianshuo.html "戳我")）

那么，当你掌握了某些计算机语言之后，同样有三种工作机会：

1. 找个要你的软件公司，什么软件不重要，但是工资越高越好
2. 找个自己喜欢的软件公司，即使它目前规模很小，给你的待遇很低
3. 自己编写自己想要实现的软件（创业），给他人创造价值，即使你前途一片未知

现在你能力怎么样？你又会怎么选？

（这个类比充分证明了多写作，能梳理思绪，更能发现惊喜，能把[乔布斯斯坦福大学演讲](https://www.youtube.com/watch?v=5xM0KfaYV_0 "乔布斯斯坦福大学演讲")中的第一个故事中那些 dots 连接起来。)
